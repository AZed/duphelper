#!/usr/bin/perl
use warnings; use strict;
use English qw( -no_match_vars );

### Perl Critic Notes ###
#
## no critic qw(InputOutput::ProhibitBacktickOperators)
#
# Using IPC::open3 in place of backticks adds complexity and reduces
# readability for the dubious gain of capturing stderr even when it's
# perfectly reasonable for stderr to just dump to the console.
#
## no critic qw(ValuesAndExpressions::ProhibitConstantPragma)
#
# We are using constants for exit values.  These will never be
# interpolated, and ReadOnly is not a core module.
#
## no critic qw(ValuesAndExpressions::ProhibitMagicNumbers)
#
# Anything that involves setting default values will actually be less
# readable if those values are concealed behind names in a different
# part of the code.
#
## no critic qw(RegularExpressions::RequireDotMatchAnything)
#
# Tampering with the default behavior of regular expressions can be
# more confusing than not, depending on what behavior you are used to.
#
## no critic qw(ValuesAndExpressions::ProhibitEmptyQuotes)
## no critic qw(ValuesAndExpressions::ProhibitNoisyQuotes)
#
# I just generally disagree about which format is more readable
#
## no critic qw(Subroutines::ProhibitExcessComplexity)
#
# This would normally complain about dupback, which is actually very
# simple code, just long because we have to handle a large number of
# options.
#
## no critic qw(Variables::RequireLocalizedPunctuationVars)
#
# We are deliberately tampering with $ENV{'HOME'} in a global scope
#

=head1 NAME

duphelper - duplicity backup helper system

=head1 SYNOPSIS

 duphelper COMMAND arg1 arg2 --opt1 --opt2

See also Usage and Examples in the documentation for each COMMAND, below.

=cut

use Config::IniFiles;
use File::Basename;
use File::Path qw(mkpath);
use File::Spec;
use IPC::Open3;
use Getopt::Long;
use Sys::Hostname;
use Time::localtime;

# Exit values
use constant EXIT_SUCCESS       => 0;
use constant EXIT_BADCOMMAND    => 1;
use constant EXIT_SYSTEMFAIL    => 2;
use constant EXIT_DUPLICITYFAIL => 3;
use constant EXIT_CONFIGERROR   => 4;
use constant EXIT_INTERNALERROR => 5;


#####################################
########## OPTION HANDLING ##########
#####################################

=head1 CONFIGURATION FILES

Duphelper will check in two directories for configuration files:
/usr/local/etc/duplicity and /etc/duplicity, in that order.  It will
first check for a configuration file in the format of
duphelper@base-path.cfg, where the first '/' in a path is converted to
a '@' and all subsequent '/' characters are converted to '-'.

For example, '/' will convert just to '@', '/usr/local/etc' will
convert to '@usr-local-etc', and YES this implies that if you have
'/usr/local-etc and /usr/local/etc on the same system, you will have
problems trying to back them up separately with this helper, so don't
do that.)

If no location-specific configuration files are found, duphelper.cfg
will be used for global defaults for all backups.

=head1 OPTIONS

=head2 Duphelper Options

The following options either affect behavior particular to Duphelper
itself or have special handling applied before being passed to
Duplicity.  They override values found in the configuration file, if
any.

=over

=item --archive-dir-hostname

If this is set to true, the base Duplicity archive-dir will always
have the hostname appended as a path component.

=item --cleancount

The number of backups to keep when purging backups with dupcleancount

=item --cleaninterval

Default: '1Y'

The time after which old backups are purged by dupclean

=item --encrypt-key

Encrypt the backup to this GPG key.  This option can be specified
multiple times to allow a backup to be decrypted by multiple keys.

=item --full

Forces a full backup by setting fullinterval to 'now', discarding any
value specified by --fullinterval.

=item --fullinterval

Default: '1M'

This is the time after which a full backup is forced.  If set to
'now', a full backup will always be performed.

=item --home

This will set the environment variable HOME before the duplicity call,
e.g. to force root's .gnupg directory to be used.

=item --hostname | -h

This overrides the default detected hostname.  This is sometimes
useful when restoring a file from the backup of a completely different
machine, but should only be used with caution.

=item --noop

Print out the duplicity command that would be executed without
actually running it.

=item --outputlog

This is the base name of the log of stdout and stderr from system
calls.  It will have appended to it the modified backup path (matching
the cache directory naming) and .log.

Example: '/var/log/duplicity' will result in logfiles with names such
as '/var/log/duplicity-@home.log'.

The default value is '-', which is a special case that causes stdout
and stderr to be output normally and not placed in a log file.

=item --remotedir

=item --remotehost

=item --remoteport

=item --remoteproto

=item --remoteuser

Remote protocol, user, host, port, and backup path

This will be used to generate the remote URL in the format:

    {remoteproto}://{remoteuser}@{remotehost}:{remoteport}{remotedir}

If {remoteuser} is empty, the @ is skipped.

If {remoteport} is empty, the colon is skipped.

If {remoteport} is given, it will also automatically be added to
ssh-options, below, and should not be specified there.

=item --remoteym

Append a YYYYMM directory to the remote path after the hostname
(this is to put a limit on the local cache when many backups are kept)

If 0 (or undefined), does not append anything (uses just the hostname)

If 1, uses the current year and month

If a six-digit numeric value is provided, uses that

If anything else, a warning is displayed and just the hostname is used

=item --rootexclude

This specifies a file or directory to be excluded specifically from
backups of '/'.  If a target other than '/' is in use, these values
will not apply.

This option can be specified multiple times to exclude multiple files
or directories.

=item --separate-subdirs | --sepsub

If this is specified, then all subdirectories of the target directory
will be excluded from the main backup, and then backed up one by one
separately.

Use caution with this option -- this will make it much easier to
accidentally end up with a path naming conflict if you have
directories with hyphenated names (/path/a/b/c may not be backed up as
a separate direct target from /path/a-b/c)

Any separately handled subdirectories will still use the configuration
file of the main target directory.  If you need them to use their own
config files, exclude them from the top directory manually and invoke
duphelper a second time to target them specifically.

=item --separate-subdirs-list || --sepsublist

If this is specified, a limited list of subdirectories of the target
directory will be excluded from the main backup, and then backed up
one by one separately.

See the caution notes on --separate-subdirs, above.  If both
--separate-subdirs and --separate-subdirs-list are specified,
--separate-subdirs wins (i.e. the any list you specify in
--separate-subdirs will be ignored and replaced with a list of all
subdirectories of the main target directory).

=back

=head2 Duplicity Options

The following options are passed verbatim to Duplicity as appropriate.
For more details on what they do, see the duplicity documentation.

=over

=item --archive-dir

=item --dry-run

=item --exclude-device-files

=item --exclude-filelist

Default: '/etc/duplicity/exclude'

This specifies a global exclusion list that will be applied to all
dupback calls.  As full pathnames starting from the filesystem root
are required, and backups starting at different paths will abort with
an error if they find an exclude that isn't in their path, this is
only useful if you are only making a single backup or if you are
making backups with overlapping paths.  Normally, you want to use the
globbing version, below.

=item --exclude-globbing-filelist

Default: '/etc/duplicity/exclude.glob'

This specifies a global exclusion list that will be applied to all
dupback calls, with glob parsing applied.  A common use for this is to
declare particular files or directories that will always be ignored in
all backups, such as:

 **/nobackup
 **/private

=item --exclude-other-filesystems

=item --gpg-options

=item --log-file

=item --no-encryption

=item --no-print-statistics

=item --ssh-backend

Allows the explicit selection of a ssh backend.  Valid values are 'paramiko' and 'pexpect'

=item --ssh-options

=item --tempdir

=item --time

=item --verbosity

=item --volsize

=back

=cut

my $backuppath = $ARGV[0] || '/';
my %opt = parse_options($backuppath);


# Current year and month as a 6-digit string, used when remoteym is
my $yearmonth = sprintf("%04d%02d",localtime->year()+1900,localtime->mon()+1);

# Setting the home directory may be desirable to force a specific
# .aws or .gnupg directory to be used.

if($opt{'home'}) {
    $ENV{'HOME'} = $opt{'home'};
}


#######################################
########## DISPATCH HANDLING ##########
#######################################

my %dispatch = (
    'dupback' => \&dupback,
    'dupclean' => \&dupclean,
    'dupcleancount' => \&dupcleancount,
    'dupget' => \&dupget,
    'duplist' => \&duplist,
    'dupstat' => \&dupstat,
    'dupver' => \&dupver,
   );

my $command = basename($PROGRAM_NAME);

if (defined $dispatch{$command}) {
    if (@{$opt{'separate-subdirs-list'}}) {
        # First we backup the target directory excluding all subdirs
        my $opt_exclude_orig = $opt{'exclude'};
        foreach my $subdir (@{$opt{'separate-subdirs-list'}}) {
            push(@{$opt{'exclude'}},$backuppath.'/'.$subdir);
        }
        $dispatch{$command}(@ARGV);

        # Then we backup the remaining directories with the original
        # exclusion list
        $opt{'exclude'} = $opt_exclude_orig;
        my $startdir = $ARGV[0];
        foreach my $subdir (@{$opt{'separate-subdirs-list'}}) {
            shift;
            unshift(@ARGV, $startdir . '/' . $subdir);


            $dispatch{$command}(@ARGV);
        }
    }
    else {
        $dispatch{$command}(@ARGV);
    }
}
else {
    $command = shift;
    if (!$command) {
        print {*STDERR} "I don't know what to do!\n";
        print {*STDERR} "I was invoked as: $PROGRAM_NAME (with no arguments)\n";
        print {*STDERR} "(I expected to be invoked either with the name of a valid command,\nor with a valid command as my first argument.)\n";
        print {*STDERR} "Valid commands are: ",join(' ',sort keys %dispatch),"\n";
        exit EXIT_BADCOMMAND;
    }
    if (defined $dispatch{$command}) {
        $dispatch{$command}(@ARGV);
    }
    else {
        print {*STDERR} "I don't know what to do!\n";
        print {*STDERR} "I was invoked as: $PROGRAM_NAME $command\n";
        print {*STDERR} "(I expected to be invoked either with the name of a valid command,\nor with a valid command as my first argument.)\n";
        print {*STDERR} "Valid commands are: ",join(' ',sort keys %dispatch),"\n";
        exit EXIT_BADCOMMAND;
    }
    exit EXIT_SUCCESS;
}


#########################################
########## DISPATCHED COMMANDS ##########
#########################################

=head1 COMMANDS

=head2 C<dupback>

Back up a specified path

This will create a pidfile in /var/run specific to the path being
backed up, and will not run if a previous backup or clean operation is
still running on that path.

=head3 Usage

 dupback /path [FULLINTERVAL]

=head3 Examples

=head4 Most common use

 dupback /

=head4 Force a full (non-incremental) backup

 dupback / --full

=cut

sub dupback {
    my $basepath = shift;
    my $dashpath = dashpath($basepath);
    my $remoteurl = remoteurl($dashpath);

    if (! $basepath) {
        print {*STDERR} "You must specify a base path to back up!\n";
        print {*STDERR} "(Try 'dupback /' for the entire system.)\n";
        exit EXIT_BADCOMMAND;
    }

    my @syscmd = (
        "duplicity",$basepath,$remoteurl,
        "--archive-dir",$opt{'archive-dir'},
        "--name",$dashpath,
        "--verbosity",$opt{'verbosity'},
        "--volsize",$opt{'volsize'},
       );
    if($opt{'asynchronous-upload'}) {
        push(@syscmd,'--asynchronous-upload');
    }
    if($opt{'dry-run'}) {
        push(@syscmd,'--dry-run');
    }
    if($opt{'fullinterval'}) {
        push(@syscmd,'--full-if-older-than',$opt{'fullinterval'});
    }
    if($opt{'exclude'}) {
        foreach my $excluded (@{$opt{'exclude'}}) {
            push(@syscmd,'--exclude',$excluded);
        }
    }
    if($opt{'exclude-device-files'}) {
        push(@syscmd,'--exclude-device-files');
    }
    if($opt{'exclude-filelist'}) {
        if(-f $opt{'exclude-filelist'}) {
            push(@syscmd,'--exclude-filelist',$opt{'exclude-filelist'});
        }
    }
    if($opt{'exclude-globbing-filelist'}) {
        if(-f $opt{'exclude-globbing-filelist'}) {
            push(@syscmd,'--exclude-globbing-filelist',
                 $opt{'exclude-globbing-filelist'});
        }
    }
    if($opt{'log-file'}) {
        push(@syscmd,'--log-file',$opt{'log-file'});
    }
    if($opt{'no-print-statistics'}) {
        push(@syscmd,'--no-print-statistics');
    }
    if($opt{'ssh-backend'}) {
        push(@syscmd,'--ssh-backend',$opt{'ssh-backend'});
    }
    if($opt{'ssh-options'}) {
        push(@syscmd,'--ssh-options',$opt{'ssh-options'});
    }
    if($opt{'tempdir'}) {
        push(@syscmd,'--tempdir',$opt{'tempdir'});
    }

    # Root exclusions
    if($basepath eq '/') {
        if($opt{'rootexclude'}) {
            foreach my $excl (@{$opt{'rootexclude'}}) {
                push(@syscmd,'--exclude',$excl);
            }
        }
    }

    # Encryption option handling
    if($opt{'no-encryption'}) {
        push(@syscmd,'--no-encryption');
    }
    if($opt{'gpg-options'}) {
        push(@syscmd,'--gpg-options',$opt{'gpg-options'});
    }
    if($opt{'encrypt-key'}) {
        foreach my $key (@{$opt{'encrypt-key'}}) {
            push(@syscmd,'--encrypt-key',$key);
        }
    }

    remote_create_dir($opt{'remoteproto'});

    if($opt{'noop'}) {
        print "Not executing: ",join(' ',@syscmd),"\n";
        return EXIT_SUCCESS;
    }

    system_logged($dashpath,@syscmd);
    return EXIT_SUCCESS;
}


=head2 C<dupclean>

Remove all backups older than the 'cleaninterval' time.

Also runs 'duplicity cleanup' to delete extraneous duplicity files
left over from aborted or failed backups.

It is possible for this command to leave you without any backups if
all of your backups are old.  For a safer alternative, use
dupcleancount.

This will create a pidfile in /var/run specific to the path being
backed up, and will not run if a previous backup or clean operation is
still running on that path.

=head3 Usage

 dupclean <path>

If <path> is not specified, defaults to '/'

=cut

sub dupclean {
    my $basepath = shift;
    if(!defined $basepath) { $basepath = '/'; }
    my $dashpath = dashpath($basepath);
    my $remoteurl = remoteurl($dashpath);

    my @syscmd = (
        "duplicity","remove-older-than",$opt{'cleaninterval'},
        "--extra-clean","--force",
        "--archive-dir",$opt{'archive-dir'},
        "--name",$dashpath,
        "--verbosity",$opt{'verbosity'},
       );
    if($opt{'dry-run'}) {
        push(@syscmd,'--dry-run');
    }
    if($opt{'no-print-statistics'}) {
        push(@syscmd,'--no-print-statistics');
    }
    if($opt{'ssh-backend'}) {
        push(@syscmd,'--ssh-backend',$opt{'ssh-backend'});
    }
    if($opt{'ssh-options'}) {
        push(@syscmd,'--ssh-options',$opt{'ssh-options'});
    }
    if($opt{'tempdir'}) {
        push(@syscmd,'--tempdir',$opt{'tempdir'});
    }
    push(@syscmd,$remoteurl);

    if($opt{'noop'}) {
        print "Not executing: ",join(' ',@syscmd),"\n";
    }
    else {
        system_logged($dashpath,@syscmd);
    }

    @syscmd = (
        'duplicity','cleanup','--extra-clean','--force',
        '--verbosity',$opt{'verbosity'},
       );
    if($opt{'dry-run'}) {
        push(@syscmd,'--dry-run');
    }
    if($opt{'ssh-backend'}) {
        push(@syscmd,'--ssh-backend',$opt{'ssh-backend'});
    }
    if($opt{'ssh-options'}) {
        push(@syscmd,'--ssh-options',$opt{'ssh-options'});
    }
    if($opt{'tempdir'}) {
        push(@syscmd,'--tempdir',$opt{'tempdir'});
    }
    push(@syscmd,$remoteurl);

    if($opt{'noop'}) {
        print "Not executing: ",join(' ',@syscmd),"\n";
        return EXIT_SUCCESS;
    }
    else {
        system_logged($dashpath,@syscmd);
        return EXIT_SUCCESS;
    }
}


=head2 C<dupcleancount>

Remove all backups except the last 'cleancount' backups.

This will create a pidfile in /var/run specific to the path being
backed up, and will not run if a previous backup or clean operation is
still running on that path.

=head3 Usage

 dupcleancount <path> <count>

If <path> is not specified, defaults to '/'

Also, <path> must be specified to use <count> as an argument (though
the count can also be specified with --cleancount)

=cut

sub dupcleancount {
    my ($basepath,$count) = @_;

    if(!defined $basepath) { $basepath = '/'; }
    my $dashpath = dashpath($basepath);
    my $remoteurl = remoteurl($dashpath);

    if(defined $count) {
        $opt{'cleancount'} = $count;
    }

    my @syscmd = (
        "duplicity","remove-all-but-n-full",$opt{'cleancount'},
        "--extra-clean","--force",
        "--archive-dir",$opt{'archive-dir'},
        "--name",$dashpath,
        "--verbosity",$opt{'verbosity'},
       );
    if($opt{'dry-run'}) {
        push(@syscmd,'--dry-run');
    }
    if($opt{'no-print-statistics'}) {
        push(@syscmd,'--no-print-statistics');
    }
    if($opt{'ssh-backend'}) {
        push(@syscmd,'--ssh-backend',$opt{'ssh-backend'});
    }
    if($opt{'ssh-options'}) {
        push(@syscmd,'--ssh-options',$opt{'ssh-options'});
    }
    if($opt{'tempdir'}) {
        push(@syscmd,'--tempdir',$opt{'tempdir'});
    }
    push(@syscmd,$remoteurl);

    if($opt{'noop'}) {
        print "Not executing: ",join(' ',@syscmd),"\n";
        return EXIT_SUCCESS;
    }

    system_logged($dashpath,@syscmd);
    return EXIT_SUCCESS;
}


=head2 C<dupget>

Retrieve files/directories from a Duplicity archive

=head3 Usage

 dupget /archive/path [output-name] [dir-or-file-to-restore]

[output-name] may be a relative or absolute path, but if specified it
must not yet exist.

[dir-or-file-to-restore] should always be a relative path (i.e. no
leading slash).

The default is to retrieve the entire backup archive into the current
directory, which must be empty.

=head3 Examples

From a backup of the entire filesystem, retrieve the backup of
/usr/local/bin as /opt/local/bin:

 dupget / /opt/local/bin usr/local/bin

From a backup of /usr/local, retrieve the backup of /usr/local/bin and
write it as /opt/local/bin:

 dupget /usr/local /opt/local/bin bin

From a backup of the entire filesystem on a server named "otherhost",
retrieve the backup of /home as /home:

 dupget -h otherhost / /home home

=cut

sub dupget {
    my ($basepath,$localpath,$target) = @_;

    if(!defined $basepath) { $basepath = '/'; }
    my $dashpath = dashpath($basepath);
    my $remoteurl = remoteurl($dashpath);

    $localpath = "." unless $localpath;

    my @syscmd = (
        "duplicity","restore",$remoteurl,
        "--archive-dir",$opt{'archive-dir'},
        "--name",$dashpath,
        "--verbosity",$opt{'verbosity'},
       );
    if($opt{'dry-run'}) {
        push(@syscmd,'--dry-run');
    }
    if($opt{'no-print-statistics'}) {
        push(@syscmd,'--no-print-statistics');
    }
    if($opt{'ssh-backend'}) {
        push(@syscmd,'--ssh-backend',$opt{'ssh-backend'});
    }
    if($opt{'ssh-options'}) {
        push(@syscmd,'--ssh-options',$opt{'ssh-options'});
    }
    if($opt{'tempdir'}) {
        push(@syscmd,'--tempdir',$opt{'tempdir'});
    }
    if($opt{'time'}) {
        push(@syscmd,'--time',$opt{'time'});
    }
    if($target) {
        push(@syscmd,'--file-to-restore',$target);
    }
    push(@syscmd,$localpath);

    if($opt{'noop'}) {
        print "Not executing: ",join(' ',@syscmd),"\n";
        return EXIT_SUCCESS;
    }

    system(@syscmd);
    return system_result($CHILD_ERROR,@syscmd);
}


=head2 C<duplist>

List all files contained within the backup chain.

If --time is not specified, uses the most recent backup chain.

=head3 Usage

 duplist <path>

If <path> is not specified, defaults to '/'

=cut

sub duplist {
    my $basepath = shift;
    if(!defined $basepath) { $basepath = '/'; }
    my $dashpath = dashpath($basepath);
    my $remoteurl = remoteurl($dashpath);

    my @syscmd = (
        "duplicity","list-current-files",$remoteurl,
        "--archive-dir",$opt{'archive-dir'},
        "--name",$dashpath,
       );
    if($opt{'dry-run'}) {
        push(@syscmd,'--dry-run');
    }
    if($opt{'ssh-backend'}) {
        push(@syscmd,'--ssh-backend',$opt{'ssh-backend'});
    }
    if($opt{'ssh-options'}) {
        push(@syscmd,'--ssh-options',$opt{'ssh-options'});
    }
    if($opt{'tempdir'}) {
        push(@syscmd,'--tempdir',$opt{'tempdir'});
    }
    if($opt{'time'}) {
        push(@syscmd,'--time',$opt{'time'});
    }

    if($opt{'noop'}) {
        print "Not executing: ",join(' ',@syscmd),"\n";
        return EXIT_SUCCESS;
    }

    system(@syscmd);
    return system_result($CHILD_ERROR,@syscmd);
}


=head2 C<dupstat>

Show backup status

=head3 Usage

 dupstat <path>

If <path> is not specified, defaults to '/'

=cut

sub dupstat {
    my $basepath = shift;
    if(!defined $basepath) { $basepath = '/'; }
    my $dashpath = dashpath($basepath);
    my $remoteurl = remoteurl($dashpath);

    my @syscmd = (
        "duplicity","collection-status",$remoteurl,
        "--archive-dir",$opt{'archive-dir'},
        "--name",$dashpath,
        "--verbosity",$opt{'verbosity'},
       );
    if($opt{'dry-run'}) {
        push(@syscmd,'--dry-run');
    }
    if($opt{'gpg-options'}) {
        push(@syscmd,'--gpg-options',$opt{'gpg-options'});
    }
    if($opt{'no-print-statistics'}) {
        push(@syscmd,'--no-print-statistics');
    }
    if($opt{'ssh-backend'}) {
        push(@syscmd,'--ssh-backend',$opt{'ssh-backend'});
    }
    if($opt{'ssh-options'}) {
        push(@syscmd,'--ssh-options',$opt{'ssh-options'});
    }
    if($opt{'tempdir'}) {
        push(@syscmd,'--tempdir',$opt{'tempdir'});
    }

    if($opt{'noop'}) {
        remote_backup_exists(dashpath => $dashpath);
        print "Not executing: ",join(' ',@syscmd),"\n";
        return EXIT_SUCCESS;
    }

    if (remote_backup_exists(dashpath => $dashpath)) {
        system(@syscmd);
        return system_result($CHILD_ERROR,@syscmd);
    }
    else {
        print {*STDERR} "Remote URL has no backups or is unavailable.\n";
        return EXIT_SUCCESS;
    }
}


#######################################
########## HELPER FUNCTIONS ###########
#######################################

sub dashpath {
    # Convert a path with or without a leading slash from /a/b/c/d to
    # @a-b-c-d, generally for use in setting up backups.
    my $path = shift;

    if (! $path) {
        print {*STDERR} "FATAL: dashpath called with no argument!\n";
        exit EXIT_INTERNALERROR;
    }

    $path =~ s|^/|@|x;
    $path =~ s|/|-|gx;
    return $path;
}


sub get_ymdir {
    # Determines whether or not a remote year-month directory
    # component is in use (as specified in the options or config
    # file), calculates it if required, and returns the appropriate
    # string to be used in the full path specification.
    #
    # Returns undef if the directory is not to be used or an invalid
    # (non-6-digit-numeric) value is specified.

    my $ymdir;

    if ($opt{'remoteym'}) {
        if ($opt{'remoteym'} == 1) {
            $ymdir = $yearmonth;
        }
        elsif ($opt{'remoteym'} =~ /\d{6}/x) {
            $ymdir = $opt{'remoteym'};
        }
        else {
            print {*STDERR} "WARNING: Ignoring invalid remoteym option: "
                            . $opt{'remoteym'} . "\n";
        }
    }

    return $ymdir;
}

sub loadconfig {
    # Load configuration options from a configuration file
    #
    # We check first for duphelper@path.cfg in
    # /usr/local/etc/duplicity and /etc/duplicity, then if neither is
    # found, duphelper.cfg in /usr/local/etc/duplicity and
    # /etc/duplicity, in that order.
    #
    # This will be called automatically from parse_options()

    my ($backuppath) = @_;
    my $dashpath = dashpath($backuppath);

    my $config;
    my @configpaths = ('/usr/local/etc/duplicity/',
                       '/etc/duplicity/');
    my @possibleconfigs;

    if ($dashpath) {
        foreach my $configpath (@configpaths) {
            push (@possibleconfigs,
                  $configpath . "duphelper" . $dashpath . ".cfg");
        }
    }
    foreach my $configpath (@configpaths) {
        push (@possibleconfigs,$configpath . "duphelper.cfg");
    }

    foreach my $configfile (@possibleconfigs) {
        if (-f $configfile ) {
            $config = Config::IniFiles->new( -file => $configfile );

            # Special check to disable --separate-subdirs in the
            # default config file
            (my $basename,undef,undef) = fileparse($configfile);
            if($basename eq 'duphelper.cfg') {
                $config->setval('duphelper','separate-subdirs',0);
            }

            last;
        }
    }
    $config = Config::IniFiles->new() unless($config);

    return $config;
}


sub parse_options {
    # Parse command-line options and use them to override values from
    # the configuration file

    my ($backuppath) = @_;

    my $config = loadconfig($backuppath);

    # Array option pre-handling
    my @config_encryptkeys = $config->val('encryption','encrypt-key');
    my @config_rootexclude = $config->val('duphelper','rootexclude');
    my @config_subdirs_list = $config->val('duphelper','separate-subdirs-list');

    # Default option values
    my %opt = (
        'archive-dir'       => $config->val('duplicity','archive-dir') || '/var/cache/duplicity',
        'archive-dir-hostname' => $config->val('duphelper','archive-dir-hostname') || 1,
        'asynchronous-upload' => $config->val('duplicity','asynchronous-upload') || 0,
        'cleancount'        => $config->val('duphelper','cleancount') || 2,
        'cleaninterval'     => $config->val('duphelper','cleaninterval') || '1Y',
        'dry-run'           => undef,
        'encrypt-key'       => \@config_encryptkeys || undef,
        'exclude-device-files' => $config->val('duplicity','exclude-device-files') || 0,
        'exclude-filelist'  => $config->val('duplicity','exclude-filelist') || '/etc/duplicity/exclude',
        'exclude-globbing-filelist' => $config->val('duplicity','exclude-globbing-filelist') || '/etc/duplicity/exclude.glob',
        'exclude-other-filesystems' => $config->val('duplicity','exclude-other-filesystems') || 0,
        'full'              => undef,
        'fullinterval'      => $config->val('duphelper','fullinterval') || '1M',
        'gpg-options'       => $config->val('encryption','gpg-options') || '',
        'home'              => $config->val('duphelper','home') || undef,
        'hostname'          => $config->val('duphelper','hostname') || hostname(),
        'log-file'          => $config->val('duplicity','log-file') || undef,
        'no-encryption'     => $config->val('encryption','no-encryption') || 0,
        'no-print-statistics' => $config->val('duplicity','no-print-statistics') || 0,
        'noop'              => 0,
        'outputlog'         => $config->val('duphelper','outputlog') || '-',
        'remotedir'         => $config->val('duphelper','remotedir') || undef,
        'remotehost'        => $config->val('duphelper','remotehost') || undef,
        'remoteport'        => $config->val('duphelper','remoteport') || undef,
        'remoteproto'       => $config->val('duphelper','remoteproto') || undef,
        'remoteuser'        => $config->val('duphelper','remoteuser') || undef,
        'remoteym'          => $config->val('duphelper','remoteym') || 0,
        'rootexclude'       => \@config_rootexclude || undef,
        'separate-subdirs'  => $config->val('duphelper','separate-subdirs') || 0,
        'separate-subdirs-list' => \@config_subdirs_list || undef,
        'ssh-backend'       => $config->val('duplicity','ssh-backend') || undef,
        'ssh-options'       => $config->val('duplicity','ssh-options') || '',
        'tempdir'           => $config->val('duplicity','tempdir') || undef,
        'time'              => undef,
        'verbosity'         => $config->val('duplicity','verbosity') || 4,
        'volsize'           => $config->val('duplicity','volsize') || 25,
       );

    GetOptions(
        \%opt,
        'archive-dir',
        'asynchronous-upload|asynchronous|async',
        'cleaninterval=s',
        'encrypt-key=s@',
        'dry-run',
        'exclude=s@',
        'exclude-device-files',
        'exclude-filelist=s',
        'exclude-globbing-filelist=s',
        'full',
        'fullinterval=s',
        'gpg-options=s',
        'home=s',
        'hostname|h=s',
        'log-file=s',
        'noop',
        'no-encryption',
        'no-print-statistics',
        'outputlog=s',
        'remotedir=s',
        'remotehost=s',
        'remoteport=s',
        'remoteproto=s',
        'remoteuser=s',
        'remoteym=s',
        'rootexclude=s@',
        'separate-subdirs|sepsub',
        'separate-subdirs-list|sepsublist=s@',
        'ssh-backend=s',
        'ssh-options=s',
        'tempdir=s',
        'time|restore-time|t=s',
        'verbosity|v=s',
        'volsize=i',
       );

    if ($opt{'archive-dir-hostname'}) {
        $opt{'archive-dir'} = $opt{'archive-dir'} . '/' . $opt{'hostname'};
    }
    mkpath($opt{'archive-dir'});

    # if remoteport is defined, we need to add it to ssh-options
    if ($opt{'remoteport'}) {
        $opt{'ssh-options'} = "-oPort=$opt{'remoteport'} " . $opt{'ssh-options'};
    }

    # --full is shorthand for --fullinterval now
    if ($opt{'full'}) {
        $opt{'fullinterval'} = 'now';
    }

    # Define the separate-subdirs-list as being all subdirectories of the target
    if ($opt{'separate-subdirs'}) {
        my $dh;
        opendir ($dh,$backuppath)
          or die ("Failed to read target directory ${backuppath}!");
        my @subdirs = grep {
            -d "${backuppath}/$_" && ! /^\.{1,2}$/x
        } readdir($dh);
        closedir($dh)
          or die ("Failed to close target directory ${backuppath} after read!");
        $opt{'separate-subdirs-list'} = \@subdirs;
    }

    return %opt;
}


sub pidfile_running {
    # Returns 1 if the specified pidfile exists and contains the PID
    # number of a running process
    #
    # Returns 0 otherwise
    #
    # Dies if a pidfile is found but cannot be opened

    my $pidfile = shift;
    my $pid;

    if ( -f $pidfile ) {
        open(my $fh_pidfile,'<',$pidfile)
          or die("Found pidfile '",$pidfile,"' but unable to open it!\n");
        $pid=<$fh_pidfile>;
        close($fh_pidfile);
        if(!$pid) {
            return 0;
        }
        if ( kill(0,$pid) ) { return 1; }
    }
    return 0;
}


sub remote_backup_exists {
    # Uses an argument hash with the following valid keys and values
    #  'dashpath'
    #    => the dashpath used for the remote directory (required)
    #  'test'
    #    => 'dir' tests for the presence of the dashpath directory itself
    #    => 'manifest' tests for the presence of manifest.gpg files in that directory
    #    The default is 'manifest'.
    #
    # Returns 1 if the tested object exists or we don't know how to
    # test the remote protocol in use.
    #
    # Returns 0 if the tested object does not exist.

    my (%args) = @_;

    my $dashpath = $args{'dashpath'};
    my $test = $args{'test'} || 'manifest';
    my $remotedir = "duplicity/" . $opt{'hostname'};
    my $ymdir;
    my $regexp;

    if (! $dashpath) {
        print {*STDERR} "WARNING: remote_backup_exists called with no path specified!\n";
        print {*STDERR} "(This should be impossible.  Please file a bug report.)\n";
        return 0;
    }

    $ymdir = get_ymdir();
    if($ymdir) {
        $remotedir .= '/' . $ymdir;
    }

    if ($test eq 'dir') {
        $regexp = qr/$remotedir\/$dashpath/x;
    }
    elsif ($test eq 'manifest') {
        $regexp = qr/$remotedir\/$dashpath\/.*\.manifest\.gpg/x;
        $remotedir .= '/' . $dashpath;
    }
    else {
        print {*STDERR} "WARNING: unrecognized backup test type: " . $test . "\n";
        return 0;
    }

    my $output;
    my @lines;

    if ($opt{'remoteproto'} =~ /^(sftp|scp|ssh)/x) {
        my $cmd = "echo '-ls " . $remotedir . "' | sftp -b - "
                  . $opt{'ssh-options'} . " "
                  . $opt{'remoteuser'} . '@' . $opt{'remotehost'}
                  . " 2> /dev/null";

        if($opt{'noop'}) {
            print "Not executing: $cmd\n";
        }
        else {
            $output = `$cmd`;
            system_result($CHILD_ERROR,$cmd);

            @lines = split(/^/x,$output);

            if ($#lines == -1) {
                print {*STDERR} "WARNING: failed to list remote parent directory!\n";
                return 0;
            }
            if ($#lines == 0) {
                # Remote parent directory is empty or nonexistent
                # sftp returned exactly one line listing the command executed
                return 0;
            }
            if (grep { /$regexp/x } @lines) {
                return 1;
            }
        }
    }
    else {
        if($opt{'verbosity'} >= 5) {
            print {*STDERR} "WARNING: unable to examine remote directories with protocol "
                            . $opt{'remoteproto'} . "\n";
            print {*STDERR} "WARNING: proceeding as if it exists anyway.\n";
        }
        return 1;
    }
    return 0;
}


sub remote_create_dir {
    # Create the destination directory if it does not yet exist

    my $proto = shift;
    my $ymdir;

    if ($proto =~ /^(sftp|scp|ssh)/x ) {
        my $cmd = "echo '-mkdir duplicity/" . $opt{'hostname'}
          . "' | sftp -b - " . $opt{'ssh-options'} . " ";
        if($opt{'remoteuser'}) {
            $cmd .= $opt{'remoteuser'} . '@';
        }
        $cmd .= $opt{'remotehost'} . " >/dev/null 2>&1";

        if($opt{'noop'}) {
            print "Not executing: $cmd\n";
        }
        else {
            system($cmd);
            system_result($CHILD_ERROR,$cmd);
        }

        # An additional directory level needs to be created when
        # remoteym is in use
        $ymdir = get_ymdir();
        if($ymdir) {
            $cmd = "echo '-mkdir duplicity/" . $opt{'hostname'} . '/'
                   . $ymdir . "' | sftp -b - " . $opt{'ssh-options'} . ' ';
            if($opt{'remoteuser'}) {
                $cmd .= $opt{'remoteuser'} . '@';
            }
            $cmd .= $opt{'remotehost'} . " >/dev/null 2>&1";

            if($opt{'noop'}) {
                print "Not executing: $cmd\n";
            }
            else {
                system($cmd);
                system_result($CHILD_ERROR,$cmd);
            }
        }
    }
    else {
        if($opt{'verbosity'} >= 5) {
            print {*STDERR} "WARNING: unable to pre-create remote directory with protocol $proto\n";
        }
    }
    return;
}


sub remoteurl {
    # Generate a full remote URL string from the option data and a
    # provided dashpath as an argument.

    my $dashpath = shift;

    if(! $dashpath) {
        print {*STDERR} "FATAL: attempted to generate a remote URL with no path!\n";
        print {*STDERR} "(This should be impossible.  Please file a bug report.)\n";
        exit EXIT_INTERNALERROR;
    }

    if(! $opt{'remoteproto'}) {
        print {*STDERR}
          "FATAL: attempted to generate a remote URL, but the remote protocol was not defined!\n";
        print {*STDERR} "(You probably need to check your configuration.)\n";
        exit EXIT_CONFIGERROR;
    }
    if(! $opt{'remotehost'}) {
        print {*STDERR}
          "FATAL: attempted to generate a remote URL, but the remote host was not defined!\n";
        print {*STDERR} "(You probably need to check your configuration.)\n";
        exit EXIT_CONFIGERROR;
    }
    if(! $opt{'remotedir'}) {
        print {*STDERR}
          "FATAL: attempted to generate a remote URL, but the remote directory was not defined!\n";
        print {*STDERR} "(You probably need to check your configuration.)\n";
        exit EXIT_CONFIGERROR;
    }

    my $remoteurl =
      $opt{'remoteproto'} . '://';
    if($opt{'remoteuser'}) {
        $remoteurl .= $opt{'remoteuser'} . '@';
    }
    $remoteurl .= $opt{'remotehost'};
    if($opt{'remoteport'}) {
        $remoteurl .= ":" . $opt{'remoteport'};
    }
    $remoteurl .= $opt{'remotedir'} . '/' . $opt{'hostname'};

    my $ymdir = get_ymdir();
    if ($ymdir) { $remoteurl .= '/' . $ymdir; }

    $remoteurl .= '/' . $dashpath;
    return $remoteurl;
}

sub system_logged {
    # Execute a system call that will be logged appropriately,
    # creating a pidfile to lock the process
    #
    # Prints a warning message and returns without doing anything if
    # there is already a pidfile containing a running process
    #
    # Dies via system_result() if the child process exits with an error

    my ($dashpath, @syscmd) = @_;
    my $pid;
    my $pidfile = "/var/run/duplicity-${dashpath}.pid";
    my $outlogfile = "$opt{'outputlog'}-${dashpath}.log";
    my $retval;

    if(pidfile_running($pidfile)) {
        print {*STDERR} "WARNING: found an active process in ${pidfile}!\n";
        print {*STDERR} "Not running:\n";
        print {*STDERR} join(' ',@syscmd),"\n";
        return;
    }

    ## no critic qw(InputOutput::ProhibitBarewordFileHandles)
    ## no critic qw(Variables::RequireInitializationForLocalVars)
    ## no critic qw(InputOutput::RequireBriefOpen)
    #
    # We're doing some mildly questionable things here to support
    # open3, which doesn't seem to support automatic writing to
    # lexical filehandles in any obvious way.
    #

    local *NULL;
    open(NULL,'<',File::Spec->devnull())
      or die("Failed to open '",File::Spec->devnull(),"' for reading!\n");
    open(my $fh_pid,'>',$pidfile)
      or die("Failed to open '",$pidfile,"' for writing!\n");

    if($opt{'outputlog'} eq '-') {
        # We are printing directly to stdout/stderr
        $pid = open3("<&NULL",">&STDOUT",">&STDERR",@syscmd);
        if(!$pid) {
            print {*STDERR} "Failed to redirect stdout/stderr from system_logged()\n";
            print {*STDERR} "System call: ",join(' ',@syscmd),"\n";
            exit EXIT_SYSTEMFAIL;
        }
        print {*$fh_pid} "${pid}\n";
        close($fh_pid) or die ("Unable to close pidfile '",$pidfile,"'!\n");

        waitpid($pid,0);
        $retval = $CHILD_ERROR;
        unlink($pidfile) or die("Unable to remove pidfile '",$pidfile,"'!\n");
    }
    else {
        local *OUTLOG;
        open(OUTLOG,'>>',$outlogfile)
          or die("Failed to open '",$outlogfile,"' for append!\n");

        $pid = open3("<&NULL",">&OUTLOG",undef,@syscmd);
        if(!$pid) {
            print {*STDERR} "Failed to redirect stdout from system_logged()\n";
            print {*STDERR} "System call: ",join(' ',@syscmd),"\n";
            exit EXIT_SYSTEMFAIL;
        }
        print {*$fh_pid} "${pid}\n";
        close($fh_pid) or die ("Unable to close pidfile '",$pidfile,"'!\n");

        waitpid($pid,0);
        $retval = $CHILD_ERROR;
        unlink($pidfile) or die("Unable to remove pidfile '",$pidfile,"'!\n");

        # We can't close NULL, but we should check on the output log
        close(OUTLOG) or die ("Unable to close output log '",$outlogfile,"'!\n");
    }
    system_result($retval,@syscmd);
    return;
}

sub system_result {
    # Parse the result of a system call
    # Returns 0 if it was a success
    # EXITS WITH AN ERROR if not!

    my ($retval,@syscmd) = @_;

    if ( ($CHILD_ERROR >> 8) == 0 )
    {
        return 0;
    }
    elsif ($CHILD_ERROR == -1) {
        print {*STDERR} "Failed to execute: $ERRNO\n";
        print {*STDERR} "System call: ",join(' ',@syscmd),"\n";
        exit EXIT_SYSTEMFAIL;
    }
    elsif ($CHILD_ERROR & 127) {
        printf {*STDERR} "Child died with signal %d, %s coredump\n",
          ($CHILD_ERROR & 127), ($CHILD_ERROR & 128) ? 'with' : 'without';
        print {*STDERR} "System call: ",join(' ',@syscmd),"\n";
        exit EXIT_SYSTEMFAIL;
    }
    else {
        printf {*STDERR} "Child exited with value %d\n", $CHILD_ERROR >> 8;
        print {*STDERR} "System call: ",join(' ',@syscmd),"\n";
        exit EXIT_SYSTEMFAIL;
   }
}


##########################
########## DATA ##########
##########################

__DATA__
#
# duphelper.cfg
#
# Configuration file for Duplicity Helper
#

[duphelper]
# If this is set nonzero, then the hostname will be appended to the
# archive dir.  Doing this lets you restore machines other than the
# current one, but is otherwise just wasted path length.
archive-dir-hostname=1

# The number of backups to keep when purging backups with dupcleancount
cleancount=2

# The default time after which old backups are purged by dupclean
cleaninterval=1Y

# The default time after which a full backup is forced
fullinterval=1M

# Override the home directory here
# home=/var/backups

# Override the default detected hostname here
# Don't do this unless you know what you are doing
# hostname=myhostname

# Remote protocol, user, host, port, and backup path
# This will be used to generate the remote URL in the format:
#
#     {remoteproto}://{remoteuser}@{remotehost}:{remoteport}{remotedir}
#
# If {remoteuser} is empty, the @ is skipped.
# If {remoteport} is empty, the colon is skipped.
# If {remoteport} is given, it will also automatically be added to
# ssh-options, below, and should not be specified there.
#remoteproto=sftp
#remoteuser=backup
#remotehost=mybackuphost
#remoteport=
#remotedir=/duplicity

# Append a YYYYMM directory to the remote path after the hostname
# (this is to put a limit on the local cache when many backups are kept)
# If 0 (or undefined), does not append anything (uses just the hostname)
# If 1, uses the current year and month
# If a six-digit numeric value is provided, uses that
# If anything else, a warning is displayed and just the hostname is used
#remoteym=0

# rootexclude directories are excluded from backups of '/'
rootexclude=/dev
rootexclude=/lost+found
rootexclude=/proc
rootexclude=/sys
rootexclude=/var/cache/duplicity

# If separate-subdirs is set to 1, then all subdirectories of the
# target directory will be excluded from the main backup, and then
# backed up one by one separately.
#
# This option will be ignored (forced off) if found in the default
# configuration file to prevent unintentional recursions that are
# unlikely to work well.  If you need separate subdir backups on the
# root directory, explicitly create a configuration file
# 'duplicity@.cfg' for it.
separate-subdirs=0

# If separate-subdirs is 0, then separate-subdirs-list can be used
# instead to specify a limited list of subdirectories that will be
# automatically excluded and backed up one by one separately.
#
# This option will also be ignored (forced empty) if found in the
# default configuration file to prevent unintentional recursions.
#separate-subdirs-list=foo
#separate-subdirs-list=bar


[duplicity]
archive-dir=/var/cache/duplicity
asynchronous-upload=0
exclude-device-files=1
exclude-filelist=/etc/duplicity/exclude
exclude-globbing-filelist=/etc/duplicity/exclude.glob
exclude-other-filesystems=0
log-file=/var/log/duplicity.log
no-print-statistics=1
#ssh-backend=pexpect
#ssh-options=-oIdentityFile=/root/.ssh/id_rsa-backup
verbosity=1
volsize=25


[encryption]
# Set no-encryption to 1 to completely disable encryption
no-encryption=0

# Encryption key list
#encrypt-key=DEADBEEF
#encrypt-key=BEEFDEAD

# Options passed through to GnuPG for backups
#gpg-options=--homedir /root/.gnupg --trust-model=always
