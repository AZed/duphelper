#!/usr/bin/perl
use warnings; use strict;

=head1 NAME

duphelper - duplicity backup helper system

=head1 SYNOPSIS

 duphelper COMMAND arg1 arg2 --opt1 --opt2

See also Usage and Examples in the documentation for each COMMAND, below.

=cut

use Config::IniFiles;
use File::Basename;
use File::Path qw(mkpath);
use Getopt::Long;
use Sys::Hostname;
use Time::localtime;

# Exit values
use constant EXIT_SUCCESS	=> 0;
use constant EXIT_BADCOMMAND	=> 1;
use constant EXIT_SYSTEMFAIL    => 2;
use constant EXIT_DUPLICITYFAIL => 3;
use constant EXIT_CONFIGERROR   => 4;
use constant EXIT_INTERNALERROR => 5;


########################################
########## CONFIGURATION FILE ##########
########################################

# Check first /usr/local/etc/duplicity and then /usr/local/duplicity
my $config;
my $configfile1 = "/usr/local/etc/duplicity/duphelper.cfg";
my $configfile2 = "/etc/duplicity/duphelper.cfg";

if(-f $configfile1)
{
    $config = Config::IniFiles->new( -file => $configfile1 );
}
elsif(-f $configfile2)
{
    $config = Config::IniFiles->new( -file => $configfile2 );
}
$config = Config::IniFiles->new() unless($config);


#####################################
########## OPTION HANDLING ##########
#####################################

# Array option pre-handling
my @config_encryptkeys = $config->val('encryption','encrypt-key');
my @config_rootexclude = $config->val('duphelper','rootexclude');

# Default option values
my %opt = (
    'archive-dir'	=> $config->val('duplicity','archive-dir') || '/var/cache/duplicity',
    'archive-dir-hostname' => $config->val('duphelper','archive-dir-hostname') || 1,
    'cleancount'	=> $config->val('duphelper','cleancount') || 2,
    'cleaninterval'	=> $config->val('duphelper','cleaninterval') || '1Y',
    'dry-run'		=> undef,
    'encrypt-key'	=> \@config_encryptkeys || undef,
    'exclude-device-files' => $config->val('duplicity','exclude-device-files') || 0,
    'exclude-other-filesystems' => $config->val('duplicity','exclude-other-filesystems') || 0,
    'file-to-restore'	=> undef,
    'full'		=> undef,
    'fullinterval'	=> $config->val('duphelper','fullinterval') || '1M',
    'gpg-options'	=> $config->val('encryption','gpg-options') || '',
    'home'		=> $config->val('duphelper','home') || undef,
    'hostname'		=> $config->val('duphelper','hostname') || hostname(),
    'log-file'		=> $config->val('duplicity','log-file') || undef,
    'no-encryption'	=> $config->val('encryption','no-encryption') || 0,
    'no-print-statistics' => $config->val('duplicity','no-print-statistics') || 0,
    'noop'		=> 0,
    'remotedir'		=> $config->val('duphelper','remotedir') || undef,
    'remotehost'	=> $config->val('duphelper','remotehost') || undef,
    'remoteport'	=> $config->val('duphelper','remoteport') || undef,
    'remoteproto'	=> $config->val('duphelper','remoteproto') || undef,
    'remoteuser'	=> $config->val('duphelper','remoteuser') || undef,
    'remoteym'		=> $config->val('duphelper','remoteym') || 0,
    'rootexclude'	=> \@config_rootexclude || undef,
    'ssh-options'	=> $config->val('duplicity','ssh-options') || '',
    'time'		=> undef,
    'urlbase'		=> $config->val('duphelper','urlbase') || undef,
    'verbosity'		=> $config->val('duplicity','verbosity') || 4,
    'volsize'		=> $config->val('duplicity','volsize') || 25,
   );

GetOptions(
    \%opt,
    'archive-dir',
    'cleaninterval=s',
    'encrypt-key=s@',
    'dry-run',
    'exclude=s@',
    'exclude-device-files',
    'file-to-restore=s',
    'full',
    'fullinterval=s',
    'gpg-options=s',
    'home=s',
    'hostname|h=s',
    'log-file=s',
    'noop',
    'no-encryption',
    'no-print-statistics',
    'remotedir=s',
    'remotehost=s',
    'remoteport=s',
    'remoteproto=s',
    'remoteuser=s',
    'remoteym=s',
    'rootexclude=s@',
    'ssh-options=s',
    'time|restore-time|t=s',
    'urlbase=s',
    'verbosity|v=s',
    'volsize=i',
   );

if($opt{'archive-dir-hostname'}) {
    $opt{'archive-dir'} = $opt{'archive-dir'} . '/' . $opt{'hostname'};
}
mkpath($opt{'archive-dir'});

# if remoteport is defined, we need to add it to ssh-options
if($opt{'remoteport'}) {
    $opt{'ssh-options'} = "-oPort=$opt{'remoteport'} " . $opt{'ssh-options'};
}

# --full is shorthand for --fullinterval now
if($opt{'full'}) {
    $opt{'fullinterval'} = 'now';
}

# Current year and month as a 6-digit string, used when remoteym is
my $yearmonth = sprintf("%04d%02d",localtime->year()+1900,localtime->mon()+1);


#######################################
########## DISPATCH HANDLING ##########
#######################################

my %dispatch = (
    'dupback' => \&dupback,
    'dupclean' => \&dupclean,
    'dupcleancount' => \&dupcleancount,
    'dupget' => \&dupget,
    'duplist' => \&duplist,
    'dupstat' => \&dupstat,
    'dupver' => \&dupver,
   );

my $command = basename($0);
if (defined $dispatch{$command}) {
    $dispatch{$command}(@ARGV);
}
else {
    $command = shift;
    if (!$command) {
        print {*STDERR} "I don't know what to do!\n";
        print {*STDERR} "I was invoked as: $0 (with no arguments)\n";
        print {*STDERR} "(I expected to be invoked either with the name of a valid command,\nor with a valid command as my first argument.)\n";
        print {*STDERR} "Valid commands are: ",join(' ',sort keys %dispatch),"\n";
        exit EXIT_BADCOMMAND;
    }
    if (defined $dispatch{$command}) {
        $dispatch{$command}(@ARGV);
    }
    else {
        print {*STDERR} "I don't know what to do!\n";
        print {*STDERR} "I was invoked as: $0 $command\n";
        print {*STDERR} "(I expected to be invoked either with the name of a valid command,\nor with a valid command as my first argument.)\n";
        print {*STDERR} "Valid commands are: ",join(' ',sort keys %dispatch),"\n";
        exit EXIT_BADCOMMAND;
    }
}


#########################################
########## DISPATCHED COMMANDS ##########
#########################################

=head1 COMMANDS

=head2 C<dupback>

Back up a specified path

=head3 Usage

 dupback /path [FULLINTERVAL]

=head3 Examples

=head4 Most common use

 dupback /

=head4 Force a full (non-incremental) backup

 dupback / --full

=cut

sub dupback {
    my $basepath = shift;
    my $dashpath = dashpath($basepath);
    my $remoteurl = remoteurl($dashpath);

    if (! $basepath) {
        print {*STDERR} "You must specify a base path to back up!\n";
        print {*STDERR} "(Try 'dupback /' for the entire system.)\n";
        exit EXIT_BADCOMMAND;
    }

    my @syscmd = (
        "duplicity",$basepath,$remoteurl,
        "--archive-dir",$opt{'archive-dir'},
        "--name",$dashpath,
        "--verbosity",$opt{'verbosity'},
        "--volsize",$opt{'volsize'},
       );
    if($opt{'dry-run'}) {
        push(@syscmd,'--dry-run');
    }
    if($opt{'fullinterval'}) {
        push(@syscmd,'--full-if-older-than',$opt{'fullinterval'});
    }
    if($opt{'no-print-statistics'}) {
        push(@syscmd,'--no-print-statistics');
    }
    if($opt{'ssh-options'}) {
        push(@syscmd,'--ssh-options',$opt{'ssh-options'});
    }
    if($opt{'exclude'}) {
        foreach my $excluded (@{$opt{'exclude'}}) {
            push(@syscmd,'--exclude',$excluded);
        }
    }
    if($opt{'exclude-device-files'}) {
        push(@syscmd,'--exclude-device-files');
    }
    if($opt{'log-file'}) {
        push(@syscmd,'--log-file',$opt{'log-file'});
    }

    # Root exclusions
    if($basepath eq '/') {
        if($opt{'rootexclude'}) {
            foreach my $excl (@{$opt{'rootexclude'}}) {
                push(@syscmd,'--exclude',$excl);
            }
        }
    }

    # Encryption option handling
    if($opt{'no-encryption'}) {
        push(@syscmd,'--no-encryption');
    }
    if($opt{'gpg-options'}) {
        push(@syscmd,'--gpg-options',$opt{'gpg-options'});
    }
    if($opt{'encrypt-key'}) {
        foreach my $key (@{$opt{'encrypt-key'}}) {
            push(@syscmd,'--encrypt-key',$key);
        }
    }

    # Setting the home directory may be desirable to force root's
    # .gnupg directory to be used.
    if($opt{'home'}) {
        $ENV{'home'} = $opt{'home'};
    }

    remote_create_dir($opt{'remoteproto'});

    if($opt{'noop'}) {
        print "Not executing: ",join(' ',@syscmd),"\n";
        exit EXIT_SUCCESS;
    }

    system(@syscmd);
    exit system_result($?,@syscmd);
}


=head2 C<dupclean>

Remove all backups older than the 'cleaninterval' time.

=head3 Usage

 dupclean <path>

If <path> is not specified, defaults to '/'

=cut

sub dupclean {
    my $basepath = shift;
    if(!defined $basepath) { $basepath = '/'; }
    my $dashpath = dashpath($basepath);
    my $remoteurl = remoteurl($dashpath);

    my @syscmd = (
        "duplicity","remove-older-than",$opt{'cleaninterval'},
        "--extra-clean","--force",
        "--archive-dir",$opt{'archive-dir'},
        "--name",$dashpath,
        "--verbosity",$opt{'verbosity'},
       );
    if($opt{'dry-run'}) {
        push(@syscmd,'--dry-run');
    }
    if($opt{'no-print-statistics'}) {
        push(@syscmd,'--no-print-statistics');
    }
    if($opt{'ssh-options'}) {
        push(@syscmd,'--ssh-options',$opt{'ssh-options'});
    }
    push(@syscmd,$remoteurl);

    if($opt{'noop'}) {
        print "Not executing: ",join(' ',@syscmd),"\n";
        exit EXIT_SUCCESS;
    }

    system(@syscmd);
    exit system_result($?,@syscmd);
}


=head2 C<dupcleancount>

Remove all backups except the last 'cleancount' backups.

=head3 Usage

 dupcleancount <path> <count>

If <path> is not specified, defaults to '/'

Also, <path> must be specified to use <count> as an argument (though
the count can also be specified with --cleanount)

=cut

sub dupcleancount {
    my ($basepath,$count) = @_;

    if(!defined $basepath) { $basepath = '/'; }
    my $dashpath = dashpath($basepath);
    my $remoteurl = remoteurl($dashpath);

    if(defined $count) {
        $opt{'cleancount'} = $count;
    }

    my @syscmd = (
        "duplicity","remove-all-but-n-full",$opt{'cleancount'},
        "--extra-clean","--force",
        "--archive-dir",$opt{'archive-dir'},
        "--name",$dashpath,
        "--verbosity",$opt{'verbosity'},
       );
    if($opt{'dry-run'}) {
        push(@syscmd,'--dry-run');
    }
    if($opt{'no-print-statistics'}) {
        push(@syscmd,'--no-print-statistics');
    }
    if($opt{'ssh-options'}) {
        push(@syscmd,'--ssh-options',$opt{'ssh-options'});
    }
    push(@syscmd,$remoteurl);

    if($opt{'noop'}) {
        print "Not executing: ",join(' ',@syscmd),"\n";
        exit EXIT_SUCCESS;
    }

    system(@syscmd);
    exit system_result($?,@syscmd);
}


=head2 C<dupget>

Retrieve files/directories from a Duplicity archive

=head3 Usage

 dupget /archive/path [output-name] [dir-or-file-to-restore]

[output-name] may be a relative or absolute path, but if specified it
must not yet exist.

[dir-or-file-to-restore] should always be a relative path (i.e. no
leading slash).

The default is to retrieve the entire backup archive into the current
directory, which must be empty.

=head3 Examples

From a backup of the entire filesystem, retrieve the backup of
/usr/local/bin as /opt/local/bin:

 dupget / /opt/local/bin usr/local/bin

From a backup of /usr/local, retrieve the backup of /usr/local/bin and
write it as /opt/local/bin:

 dupget /usr/local /opt/local/bin bin

From a backup of the entire filesystem on a server named "otherhost",
retrieve the backup of /home as /home:

 dupget -h otherhost / /home home

=cut

sub dupget {
    my ($basepath,$localpath,$target) = @_;

    if(!defined $basepath) { $basepath = '/'; }
    my $dashpath = dashpath($basepath);
    my $remoteurl = remoteurl($dashpath);

    $localpath = "." unless $localpath;

    my @syscmd = (
        "duplicity","restore",$remoteurl,
        "--archive-dir",$opt{'archive-dir'},
        "--name",$dashpath,
        "--verbosity",$opt{'verbosity'},
       );
    if($opt{'dry-run'}) {
        push(@syscmd,'--dry-run');
    }
    if($opt{'no-print-statistics'}) {
        push(@syscmd,'--no-print-statistics');
    }
    if($opt{'ssh-options'}) {
        push(@syscmd,'--ssh-options',$opt{'ssh-options'});
    }
    if($opt{'time'}) {
        push(@syscmd,'--time',$opt{'time'});
    }
    if($target) {
        push(@syscmd,'--file-to-restore',$target);
    }
    push(@syscmd,$localpath);

    if($opt{'noop'}) {
        print "Not executing: ",join(' ',@syscmd),"\n";
        exit EXIT_SUCCESS;
    }

    system(@syscmd);
    exit system_result($?,@syscmd);
}


=head2 C<duplist>

List all files contained within the backup chain.

If --time is not specified, uses the most recent backup chain.

=head3 Usage

 duplist <path>

If <path> is not specified, defaults to '/'

=cut

sub duplist {
    my $basepath = shift;
    if(!defined $basepath) { $basepath = '/'; }
    my $dashpath = dashpath($basepath);
    my $remoteurl = remoteurl($dashpath);

    my @syscmd = (
        "duplicity","list-current-files",$remoteurl,
        "--archive-dir",$opt{'archive-dir'},
        "--name",$dashpath,
       );
    if($opt{'dry-run'}) {
        push(@syscmd,'--dry-run');
    }
    if($opt{'ssh-options'}) {
        push(@syscmd,'--ssh-options',$opt{'ssh-options'});
    }
    if($opt{'time'}) {
        push(@syscmd,'--time',$opt{'time'});
    }

    if($opt{'noop'}) {
        print "Not executing: ",join(' ',@syscmd),"\n";
        exit EXIT_SUCCESS;
    }

    system(@syscmd);
    exit system_result($?,@syscmd);
}


=head2 C<dupstat>

Show backup status

=head3 Usage

 dupstat <path>

If <path> is not specified, defaults to '/'

=cut

sub dupstat {
    my $basepath = shift;
    if(!defined $basepath) { $basepath = '/'; }
    my $dashpath = dashpath($basepath);
    my $remoteurl = remoteurl($dashpath);

    my @syscmd = (
        "duplicity","collection-status",$remoteurl,
        "--archive-dir",$opt{'archive-dir'},
        "--name",$dashpath,
        "--verbosity",$opt{'verbosity'},
       );
    if($opt{'dry-run'}) {
        push(@syscmd,'--dry-run');
    }
    if($opt{'no-print-statistics'}) {
        push(@syscmd,'--no-print-statistics');
    }
    if($opt{'ssh-options'}) {
        push(@syscmd,'--ssh-options',$opt{'ssh-options'});
    }

    if($opt{'noop'}) {
        remote_backup_exists(dashpath => $dashpath);
        print "Not executing: ",join(' ',@syscmd),"\n";
        exit EXIT_SUCCESS;
    }

    if (remote_backup_exists(dashpath => $dashpath)) {
        system(@syscmd);
        exit system_result($?,@syscmd);
    }
    else {
        print {*STDERR} "Remote URL has no backups or is unavailable.\n";
        exit EXIT_SUCCESS;
    }
}


#######################################
########## HELPER FUNCTIONS ###########
#######################################

sub dashpath {
    # Convert a path with or without a leading slash from /a/b/c/d to
    # @a-b-c-d, generally for use in setting up backups.
    my $path = shift;

    if (! $path) {
        print {*STDERR} "FATAL: dashpath called with no argument!\n";
        exit EXIT_INTERNALERROR;
    }

    $path =~ s|^/|@|;
    $path =~ s|/|-|g;
    return $path;
}


sub get_ymdir {
    # Determines whether or not a remote year-month directory
    # component is in use (as specified in the options or config
    # file), calculates it if required, and returns the appropriate
    # string to be used in the full path specification.
    #
    # Returns undef if the directory is not to be used or an invalid
    # (non-6-digit-numeric) value is specified.

    my $ymdir;

    if ($opt{'remoteym'}) {
        if ($opt{'remoteym'} == 1) {
            $ymdir = $yearmonth;
        }
        elsif ($opt{'remoteym'} =~ /\d{6}/) {
            $ymdir = $opt{'remoteym'};
        }
        else {
            print {*STDERR} "WARNING: Ignoring invalid remoteym option: "
                            . $opt{'remoteym'} . "\n";
        }
    }

    return $ymdir;
}

sub remote_backup_exists {
    # Uses an argument hash with the following valid keys and values
    #  'dashpath'
    #    => the dashpath used for the remote directory (required)
    #  'test'
    #    => 'dir' tests for the presence of the dashpath directory itself
    #    => 'manifest' tests for the presence of manifest.gpg files in that directory
    #    The default is 'manifest'.
    #
    # Returns 1 if the tested object exists or we don't know how to
    # test the remote protocol in use.
    #
    # Returns 0 if the tested object does not exist.

    my (%args) = @_;

    my $dashpath = $args{'dashpath'};
    my $test = $args{'test'} || 'manifest';
    my $remotedir = "duplicity/" . $opt{'hostname'};
    my $ymdir;
    my $regexp;

    if (! $dashpath) {
        print {*STDERR} "WARNING: remote_backup_exists called with no path specified!\n";
        print {*STDERR} "(This should be impossible.  Please file a bug report.)\n";
        return 0;
    }

    $ymdir = get_ymdir();
    if($ymdir) {
        $remotedir .= '/' . $ymdir;
    }

    if ($test eq 'dir') {
        $regexp = qr/$remotedir\/$dashpath/;
    }
    elsif ($test eq 'manifest') {
        $regexp = qr/$remotedir\/$dashpath\/.*\.manifest\.gpg/;
        $remotedir .= '/' . $dashpath;
    }
    else {
        print {*STDERR} "WARNING: unrecognized backup test type: " . $test . "\n";
        return 0;
    }

    my $output;
    my @lines;

    if ($opt{'remoteproto'} =~ /^(sftp|scp|ssh)/) {
        my $cmd = "echo '-ls " . $remotedir . "' | sftp -b - "
                  . $opt{'ssh-options'} . " "
                  . $opt{'remoteuser'} . '@' . $opt{'remotehost'}
                  . " 2> /dev/null";

        if($opt{'noop'}) {
            print "Not executing: $cmd\n";
        }
        else {
            $output = `$cmd`;
            system_result($?,$cmd);

            @lines = split(/^/,$output);

            if ($#lines == -1) {
                print {*STDERR} "WARNING: failed to list remote parent directory!\n";
                return 0;
            }
            if ($#lines == 0) {
                # Remote parent directory is empty or nonexistent
                # sftp returned exactly one line listing the command executed
                return 0;
            }
            if (grep(/$regexp/,@lines)) {
                return 1;
            }
        }
    }
    else {
        print {*STDERR} "WARNING: unable to examine remote directories with protocol "
                        . $opt{'remoteproto'} . "\n";
        print {*STDERR} "WARNING: proceeding as if it exists anyway.\n";
        return 1;
    }
    return 0;
}


sub remote_create_dir {
    # Create the destination directory if it does not yet exist

    my $proto = shift;
    my $ymdir;

    if ($proto =~ /^(sftp|scp|ssh)/ ) {
        my $cmd = "echo '-mkdir duplicity/" . $opt{'hostname'}
          . "' | sftp -b - " . $opt{'ssh-options'} . " "
          . $opt{'remoteuser'} . '@' . $opt{'remotehost'}
          . " >/dev/null 2>&1";

        if($opt{'noop'}) {
            print "Not executing: $cmd\n";
        }
        else {
            system($cmd);
            system_result($?,$cmd);
        }

        # An additional directory level needs to be created when
        # remoteym is in use
        $ymdir = get_ymdir();
        if($ymdir) {
            $cmd = "echo '-mkdir duplicity/" . $opt{'hostname'}
                   . '/' . $ymdir . "' | sftp -b - " . $opt{'ssh-options'}
                   . " " . $opt{'remoteuser'} . '@' . $opt{'remotehost'}
                   . " 2> /dev/null";

            if($opt{'noop'}) {
                print "Not executing: $cmd\n";
            }
            else {
                system($cmd);
                system_result($?,$cmd);
            }
        }
    }
    else {
        print {*STDERR} "WARNING: unable to pre-create remote directory with protocol $proto\n";
    }
}


sub remoteurl {
    # Generate a full remote URL string from the option data and a
    # provided dashpath as an argument.

    my $dashpath = shift;

    if(! $dashpath) {
        print {*STDERR} "FATAL: attempted to generate a remote URL with no path!\n";
        print {*STDERR} "(This should be impossible.  Please file a bug report.)\n";
        exit EXIT_INTERNALERROR;
    }

    if(! $opt{'remoteproto'}) {
        print {*STDERR}
          "FATAL: attempted to generate a remote URL, but the remote protocol was not defined!\n";
        print {*STDERR} "(You probably need to check your configuration.)\n";
        exit EXIT_CONFIGERROR;
    }
    if(! $opt{'remoteuser'}) {
        print {*STDERR}
          "FATAL: attempted to generate a remote URL, but the remote user was not defined!\n";
        print {*STDERR} "(You probably need to check your configuration.)\n";
        exit EXIT_CONFIGERROR;
    }
    if(! $opt{'remotehost'}) {
        print {*STDERR}
          "FATAL: attempted to generate a remote URL, but the remote host was not defined!\n";
        print {*STDERR} "(You probably need to check your configuration.)\n";
        exit EXIT_CONFIGERROR;
    }
    if(! $opt{'remotedir'}) {
        print {*STDERR}
          "FATAL: attempted to generate a remote URL, but the remote directory was not defined!\n";
        print {*STDERR} "(You probably need to check your configuration.)\n";
        exit EXIT_CONFIGERROR;
    }

    my $remoteurl =
      $opt{'remoteproto'} . '://'
      . $opt{'remoteuser'} . '@' . $opt{'remotehost'};
    if($opt{'remoteport'}) {
        $remoteurl .= ":" . $opt{'remoteport'};
    }
    $remoteurl .= $opt{'remotedir'} . '/' . $opt{'hostname'};

    my $ymdir = get_ymdir();
    if ($ymdir) { $remoteurl .= '/' . $ymdir; }

    $remoteurl .= '/' . $dashpath;
    return $remoteurl;
}


sub system_result {
    # Parse the result of a system call
    # Returns 0 if it was a success
    # EXITS WITH AN ERROR if not!

    my $retval = shift;
    my @syscmd = @_;

    if ( ($? >> 8) == 0 )
    {
        return 0;
    }
    elsif ($? == -1) {
        print {*STDERR} "Failed to execute: $!\n";
        print {*STDERR} "System call: ",join(' ',@syscmd);
        exit EXIT_SYSTEMFAIL;
    }
    elsif ($? & 127) {
        printf {*STDERR} "Child died with signal %d, %s coredump\n",
          ($? & 127), ($? & 128) ? 'with' : 'without';
        print {*STDERR} "System call: ",join(' ',@syscmd);
        exit EXIT_SYSTEMFAIL;
    }
    else {
        printf {*STDERR} "Child exited with value %d\n", $? >> 8;
        print {*STDERR} "System call: ",join(' ',@syscmd);
        exit EXIT_SYSTEMFAIL;
   }
}


##########################
########## DATA ##########
##########################

__DATA__
#
# duphelper.cfg
#
# Configuration file for Duplicity Helper
#

[duphelper]
# If this is set nonzero, then the hostname will be appended to the
# archive dir.  Doing this lets you restore machines other than the
# current one, but is otherwise just wasted path length.
archive-dir-hostname=1

# The number of backups to keep when purging backups with dupcleancount
cleancount=2

# The default time after which old backups are purged by dupclean
cleaninterval=1Y

# The default time after which a full backup is forced
fullinterval=1M

# Override the default detected hostname here
# Don't do this unless you know what you are doing
# hostname=myhostname

# Remote protocol, user, host, port, and backup path
# This will be used to generate the remote URL in the format:
# {remoteproto}://{remoteuser}@{remotehost}:{remoteport}{remotedir}
# The colon and {remoteport} will be skipped if remoteport is not given
# If remoteport is given, it will also automatically be added to
# ssh-options, below, and should not be specified there.
#remoteproto=ssh
#remoteuser=backup
#remotehost=mybackuphost
#remoteport=
#remotedir=/duplicity

# Append a YYYYMM directory to the remote path after the hostname
# (this is to put a limit on the local cache when many backups are kept)
# If 0 (or undefined), does not append anything (uses just the hostname)
# If 1, uses the current year and month
# If a six-digit numeric value is provided, uses that
# If anything else, a warning is displayed and just the hostname is used
#remoteym=0

# rootexclude directories are excluded from backups of '/'
rootexclude=/dev
rootexclude=/lost+found
rootexclude=/proc
rootexclude=/sys
rootexclude=/var/cache/duplicity


[duplicity]
archive-dir=/var/cache/duplicity
exclude-device-files=1
exclude-other-filesystems=0
log-file=/var/log/duplicity.log
no-print-statistics=1
#ssh-options=-oIdentityFile=/usr/local/share/misc/backup-key
verbosity=1
volsize=25


[encryption]
# Set no-encryption to 1 to completely disable encryption
no-encryption=0

# Encryption key list
#encrypt-key=DEADBEEF
#encrypt-key=BEEFDEAD

# Options passed through to GnuPG for backups
#gpg-options=--homedir /root/.gnupg --trust-model=always
